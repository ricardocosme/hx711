** HX711 C++11/17 driver for AVR-8
The [[file:datasheet.pdf][HX711]] is a high-resolution 24-bit ADC designed for weight scales and other applications that interface with a bridge sensor. This is a header only C++11/17 driver to interface with  [[file:datasheet.pdf][HX711]] using an ATtiny85/13A or ATmega328P.

*** Demo
**** Synchronous reading
The demo below is written in C++17, take a look at [[file:demo/c++11/read.cpp][demo/c++11/read.cpp]] to view the version with support to C++11.
#+BEGIN_SRC C++
#include <hx711.hpp>

int main() {
  hx711::adc adc{avr::io::pb4, avr::io::pb3};
  auto code = adc.read();
}
#+END_SRC
[[file:demo/c++17/read.cpp][demo/c++17/read.cpp]]

**** Asynchronous reading
The demo below is written in C++17, take a look at [[file:demo/c++11/async_read.cpp][demo/c++11/async_read.cpp]] to view the version with support to C++11.
#+BEGIN_SRC C++
#include <hx711.hpp>

int main() {
  hx711::adc adc{avr::io::pb4, avr::io::pb3};

  //event loop
  while(true) {
    if(auto code = adc.async_read())
      auto value = code.value();
  }
}
#+END_SRC
[[file:demo/c++17/async_read.cpp][demo/c++17/async_read.cpp]]

**** Gain 128/64/32
The default gain used to read is 128 at channel A, but the gain 64(ch. A) or gain 32(ch. B) can be used:
#+BEGIN_SRC C++
auto code_64 = adc.read(hx711::gain::_64); // gain=64
auto code_32 = adc.read(hx711::gain::_32); // gain=32
#+END_SRC

**** Power-down
The adc can be powered down to save energy through a call ~off()~ and it can be powered up again using the method ~on()~:

*** How to use it at my project?
1. Add an include path at your project to ~include~.
2. Ensure that the macro ~F_CPU~ is defined. [1]
3. Include the header ~hx711.hpp~ (~#include <hx711.hpp>~) and it's done.

Take a look at ~demo/read.cpp~ and ~demo/Makefile~ to see an example of the above steps. If you're lost after that, then I suggest to begin with ~demo/read.cpp~ and a command line invocation of ~avr-gcc~, for example:
#+BEGIN_SRC sh
cd demo/c++11
avr-g++ -Os -mmcu=attiny85 -std=c++11 -I../../include -DF_CPU=1000000 read.cpp
#+END_SRC

Notice, we're using in the example above an ATtiny85 configured with a clock of 1Mhz, you can change the parameters as necessary to your usage.

[1] Why this? The library uses delay functions of ~avr-libc~ and that functions, or better saying macros, they need to know what is the clock of your microcontroller.

*** Supported microcontrollers
:PROPERTIES:
:CUSTOM_ID: supported_microcontrollers
:END:
1. ATtiny13A
2. ATtiny85
3. ATmega328P

*** Requirements
1. ~avr-gcc~ with at least ~-std=c++11~. /Note: If C++14 or C++17 is used then some additional features can be offered./
2. ~avr-libc 2.0~

**** [Extra] HX711 noise
[[file:extra/noise/adc_noise.org][An experiment to measure the intrinsic noise of HX711 @ 10SPS & Gain=128.]]
